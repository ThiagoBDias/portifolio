DOCUMENTAÇÃO DE PROJETO: Portfólio com Headless CMS e Build Automatizado
Objetivo: Construir uma plataforma de portfólio e blog utilizando Firebase como Headless CMS, um painel de administração para gerenciamento de conteúdo, Astro como Gerador de Site Estático (SSG) e GitHub Actions para automação do processo de build e deploy no GitHub Pages.

Fase 0: Estrutura do Projeto e Pré-requisitos
Missão: Configurar o ambiente de desenvolvimento, a estrutura de pastas e as contas de serviço necessárias.

Estrutura de Pastas (Monorepo):
No repositório Git, crie a seguinte estrutura para separar as responsabilidades do painel de admin e do site público:

/
├── admin/      # Painel de Administração (HTML, JS, CSS simples)
├── site/       # O site público (Projeto Astro)
└── .github/
    └── workflows/ # Arquivos de automação do GitHub Actions
Pré-requisitos:

Conta no GitHub.

Conta no Firebase.

Node.js e npm instalados localmente.

Fase 1: Configuração do Backend (Firebase como Headless CMS)
Missão: Preparar o Firebase para atuar como nosso banco de dados de conteúdo, armazenamento de mídia e sistema de autenticação para o admin.

Criação do Projeto Firebase:

Acesse o console do Firebase e crie um novo projeto.

Adicione um aplicativo Web ao projeto para obter as credenciais de configuração (apiKey, authDomain, etc.).

Configurar Firestore (Banco de Dados):

No menu, vá em "Cloud Firestore" e crie um novo banco de dados em modo de produção.

Crie uma coleção chamada posts.

Adicione um documento de exemplo à coleção posts com a seguinte estrutura:

JSON

{
  "title": "Post de Exemplo",
  "slug": "post-de-exemplo",
  "contentMarkdown": "Bem-vindo ao meu novo blog! Este conteúdo é escrito em **Markdown**.",
  "coverImage": "URL_da_imagem_de_capa.jpg",
  "excerpt": "Este é um resumo curto do post.",
  "status": "published",
  "tags": ["exemplo", "tech"],
  "publishedAt": "Timestamp do Firebase",
  "createdAt": "Timestamp do Firebase"
}
Configurar Firebase Authentication:

No menu, vá em "Authentication".

Habilite o provedor de login "E-mail/senha".

Adicione seu usuário administrador manualmente no console.

Anote o "UID" do usuário criado. Ele será usado nas regras de segurança.

Configurar Firebase Storage:

No menu, vá em "Storage" e crie um novo bucket.

Aplicar Regras de Segurança:

Firestore Rules: Substitua as regras padrão pelas seguintes, inserindo o seu UID de administrador.

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Acesso público para leitura de posts publicados
    match /posts/{postId} {
      allow read: if resource.data.status == 'published';
      allow write: if request.auth.uid == 'SEU_UID_DE_ADMINISTRADOR_AQUI';
    }
    // Acesso restrito para outras coleções (ex: projetos)
    match /{collection}/{docId} {
        allow read: if true;
        allow write: if request.auth.uid == 'SEU_UID_DE_ADMINISTRADOR_AQUI';
    }
  }
}
Storage Rules: Substitua as regras padrão para permitir upload apenas pelo admin.

rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    match /{allPaths=**} {
      // Leitura pública para todas as imagens
      allow read: if true;
      // Escrita apenas para o administrador autenticado
      allow write: if request.auth.uid == 'SEU_UID_DE_ADMINISTRADOR_AQUI';
    }
  }
}
Fase 2: Construção do Painel de Administração (/admin)
Missão: Criar uma interface web estática para autenticação e gerenciamento de conteúdo (CRUD de posts) no Firebase.

Estrutura de Arquivos:
Dentro da pasta /admin, crie:

index.html: Página de login e dashboard de gerenciamento.

admin.js: Lógica de autenticação, CRUD com Firestore e upload para o Storage.

style.css: Estilos básicos.

Funcionalidades a serem implementadas em admin.js:

Inicialização do Firebase: Use as credenciais do seu aplicativo web. Armazene-as como variáveis de ambiente, se possível.

Autenticação: Crie uma tela de login que usa signInWithEmailAndPassword. Após o login, exiba o painel de gerenciamento e oculte o formulário de login. Implemente um botão de logout.

Editor de Markdown: Integre o EasyMDE ao <textarea> do formulário de criação/edição de posts.

Listagem de Posts: Ao carregar o painel, busque e liste todos os posts do Firestore (incluindo rascunhos).

Criação/Edição de Posts:

Crie um formulário com campos correspondentes ao schema do Firestore (title, contentMarkdown, etc.).

Ao submeter, gere o slug a partir do título.

Use addDoc ou setDoc para salvar os dados no Firestore.

Upload de Imagens:

Adicione um <input type="file">.

Ao selecionar um arquivo, use o SDK do Firebase Storage (ref, uploadBytes, getDownloadURL) para fazer o upload.

Após o upload, pegue a URL de download e insira-a em um campo de imagem de capa ou diretamente no editor de Markdown.

Fase 3: Construção do Site Público com Astro (/site)
Missão: Criar um site estático ultra-rápido que busca os dados do Firebase durante o processo de build.

Inicialização do Projeto Astro:

Navegue até a pasta /site e execute:

Bash

npm create astro@latest
Siga as instruções para criar um projeto básico.

Conexão com Firebase:

Instale o SDK do Firebase: npm install firebase

Crie um arquivo de serviço para inicializar o Firebase e exportar as instâncias do Firestore:
site/src/lib/firebase.js

Importante: As credenciais do Firebase aqui serão usadas apenas durante o build, no ambiente Node.js. Elas não serão expostas no navegador do cliente.

Criação das Páginas Estáticas:

Página de Listagem de Posts (site/src/pages/blog.astro):

No topo do arquivo, use o --- (frontmatter) para escrever código JavaScript que será executado no build.

Importe o serviço do Firebase e faça uma query para buscar todos os posts com status == 'published'.

No corpo do arquivo, faça um loop sobre os dados retornados para renderizar a lista de posts.

Página de Detalhe de Post (site/src/pages/blog/[slug].astro):

Esta é uma rota dinâmica. Use a função getStaticPaths do Astro.

Dentro de getStaticPaths, busque todos os posts do Firestore.

Retorne um array de objetos, onde cada objeto contém params (com o slug do post) e props (com todos os dados do post).

O Astro usará este array para gerar uma página HTML para cada post.

No corpo do arquivo, use Astro.props para acessar os dados do post e renderizar o conteúdo.

Use a biblioteca Marked.js (npm install marked) para converter o contentMarkdown em HTML.

Fase 4: Automação do Deploy com GitHub Actions
Missão: Criar um fluxo de trabalho que automaticamente faz o build do site Astro e o deploy para o GitHub Pages sempre que houver uma alteração no código.

Configuração dos Segredos no GitHub:

No seu repositório do GitHub, vá em Settings > Secrets and variables > Actions.

Crie "Repository secrets" para todas as suas credenciais do Firebase (apiKey, authDomain, etc.). Ex: FIREBASE_PUBLIC_API_KEY, FIREBASE_PUBLIC_PROJECT_ID, etc. Isso é crucial para que o processo de build possa se autenticar no Firebase de forma segura.

Criação do Workflow:

Crie o arquivo .github/workflows/deploy.yml na raiz do projeto.

Cole o seguinte código no arquivo:

YAML

name: Build and Deploy Astro Site

on:
  push:
    branches:
      - main # Dispara o workflow em pushes para a branch 'main'
  workflow_dispatch: # Permite disparar manualmente

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./site # Executa todos os comandos dentro da pasta /site

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: './site/package-lock.json'

      - name: Install dependencies
        run: npm install

      - name: Build Astro site
        # Passa os segredos do GitHub como variáveis de ambiente para o build
        run: npm run build
        env:
          FIREBASE_PUBLIC_API_KEY: ${{ secrets.FIREBASE_PUBLIC_API_KEY }}
          FIREBASE_PUBLIC_AUTH_DOMAIN: ${{ secrets.FIREBASE_PUBLIC_AUTH_DOMAIN }}
          FIREBASE_PUBLIC_PROJECT_ID: ${{ secrets.FIREBASE_PUBLIC_PROJECT_ID }}
          FIREBASE_PUBLIC_STORAGE_BUCKET: ${{ secrets.FIREBASE_PUBLIC_STORAGE_BUCKET }}
          FIREBASE_PUBLIC_MESSAGING_SENDER_ID: ${{ secrets.FIREBASE_PUBLIC_MESSAGING_SENDER_ID }}
          FIREBASE_PUBLIC_APP_ID: ${{ secrets.FIREBASE_PUBLIC_APP_ID }}

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./site/dist # Pasta de saída do build do Astro
Configuração do GitHub Pages:

No seu repositório, vá em Settings > Pages.

Em "Build and deployment", selecione Source como Deploy from a branch.

Selecione a branch gh-pages como a fonte. (A action peaceiris/actions-gh-pages criará e enviará o conteúdo para esta branch automaticamente).

Com esta documentação, o Copilot terá o contexto completo para ajudar na implementação de cada arquivo e funcionalidade, passo a passo, seguindo as melhores práticas de engenharia de software.